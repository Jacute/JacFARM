package exploit_runner

import (
	"context"
	"exploit_runner/internal/models"
	"exploit_runner/internal/services/exploit_runner/mocks"
	"exploit_runner/pkg/common_config"
	"log/slog"
	"net"
	"testing"
	"time"

	"github.com/jacute/prettylogger"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/mock/gomock"
)

func TestLoadConfig(t *testing.T) {
	testCtx := context.Background()

	ctl := gomock.NewController(t)
	defer ctl.Finish()
	storageMock := mocks.NewStorageMock(ctl)
	queueMock := mocks.NewQueueMock(ctl)
	fakeLog := slog.New(prettylogger.NewDiscardHandler())

	storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigFlagFormatKey).Return("[A-Z0-9]{31}=", nil)
	teams := []*models.Team{
		{ID: 1, Name: "Team 1", IP: net.ParseIP("10.10.1.2")},
		{ID: 2, Name: "Team 2", IP: net.ParseIP("10.10.2.2")},
	}
	storageMock.EXPECT().GetTeams(testCtx).Return(teams, nil)
	storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigExploitDuration).Return("5m", nil)
	storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigExploitMaxWorkingTime).Return("10m", nil)
	storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigMaxConcurrentExploits).Return("3", nil)

	er, err := New(fakeLog, storageMock, queueMock, "test/exploit/dir")
	require.NoError(t, err)

	require.Equal(t, er.cfg.flagFormatRegexp.String(), "[A-Z0-9]{31}=")
	require.Equal(t, er.cfg.exploitRunPeriod, 5*time.Minute)
	require.Equal(t, er.cfg.exploitMaxWorkingTime, 10*time.Minute)
	require.Equal(t, er.cfg.maxConcurrentExploits, 3)
	require.Len(t, er.cfg.teams, 2)
	require.Equal(t, teams, er.cfg.teams)
}

func TestLoadConfigErrors(t *testing.T) {
	testCtx := context.Background()

	ctl := gomock.NewController(t)
	defer ctl.Finish()
	storageMock := mocks.NewStorageMock(ctl)
	queueMock := mocks.NewQueueMock(ctl)
	fakeLog := slog.New(prettylogger.NewDiscardHandler())

	testcases := []struct {
		name    string
		mock    func() *mocks.StorageMock
		wantErr bool
	}{
		{
			name: "error getting flag format",
			mock: func() *mocks.StorageMock {
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigFlagFormatKey).Return("", assert.AnError)
				return storageMock
			},
			wantErr: true,
		},
		{
			name: "error compiling flag format regexp",
			mock: func() *mocks.StorageMock {
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigFlagFormatKey).Return("[A-Z0-9{31}=", nil)
				return storageMock
			},
			wantErr: true,
		},
		{
			name: "error getting teams",
			mock: func() *mocks.StorageMock {
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigFlagFormatKey).Return("[A-Z0-9]{31}=", nil)
				storageMock.EXPECT().GetTeams(testCtx).Return(nil, assert.AnError)
				return storageMock
			},
			wantErr: true,
		},
		{
			name: "error getting exploit run duration",
			mock: func() *mocks.StorageMock {
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigFlagFormatKey).Return("[A-Z0-9]{31}=", nil)
				storageMock.EXPECT().GetTeams(testCtx).Return([]*models.Team{}, nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigExploitDuration).Return("", assert.AnError)
				return storageMock
			},
			wantErr: true,
		},
		{
			name: "error parsing exploit run duration",
			mock: func() *mocks.StorageMock {
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigFlagFormatKey).Return("[A-Z0-9]{31}=", nil)
				storageMock.EXPECT().GetTeams(testCtx).Return([]*models.Team{}, nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigExploitDuration).Return("invalid_duration", nil)
				return storageMock
			},
			wantErr: true,
		},
		{
			name: "error getting exploit max working time",
			mock: func() *mocks.StorageMock {
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigFlagFormatKey).Return("[A-Z0-9]{31}=", nil)
				storageMock.EXPECT().GetTeams(testCtx).Return([]*models.Team{}, nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigExploitDuration).Return("5m", nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigMaxConcurrentExploits).Return("5", nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigExploitMaxWorkingTime).Return("", assert.AnError)
				return storageMock
			},
			wantErr: true,
		},
		{
			name: "error parsing exploit max working time",
			mock: func() *mocks.StorageMock {
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigFlagFormatKey).Return("[A-Z0-9]{31}=", nil)
				storageMock.EXPECT().GetTeams(testCtx).Return([]*models.Team{}, nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigExploitDuration).Return("5m", nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigMaxConcurrentExploits).Return("5", nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigExploitMaxWorkingTime).Return("invalid_duration", nil)
				return storageMock
			},
			wantErr: true,
		},
		{
			name: "error getting max concurrent exploits",
			mock: func() *mocks.StorageMock {
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigFlagFormatKey).Return("[A-Z0-9]{31}=", nil)
				storageMock.EXPECT().GetTeams(testCtx).Return([]*models.Team{}, nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigExploitDuration).Return("5m", nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigMaxConcurrentExploits).Return("", assert.AnError)
				return storageMock
			},
			wantErr: true,
		},
		{
			name: "error parsing max concurrent exploits",
			mock: func() *mocks.StorageMock {
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigFlagFormatKey).Return("[A-Z0-9]{31}=", nil)
				storageMock.EXPECT().GetTeams(testCtx).Return([]*models.Team{}, nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigExploitDuration).Return("5m", nil)
				storageMock.EXPECT().GetConfigParameter(testCtx, common_config.ConfigMaxConcurrentExploits).Return("invalid_number", nil)
				return storageMock
			},
			wantErr: true,
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(tt *testing.T) {
			storageMock := tc.mock()
			er, err := New(fakeLog, storageMock, queueMock, "test/exploit/dir")
			if tc.wantErr {
				require.Error(t, err)
				require.Nil(t, er)
			} else {
				require.NoError(t, err)
				require.NotNil(t, er)
			}
		})
	}
}
