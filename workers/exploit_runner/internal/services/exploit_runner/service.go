package exploit_runner

import (
	"context"
	"exploit_runner/internal/models"
	"exploit_runner/internal/rabbitmq"
	"fmt"
	"log/slog"
	"sync"
	"time"

	"github.com/jacute/prettylogger"
)

//go:generate mockgen -source=service.go -destination=./mocks/storage_mock.go -package=mocks -mock_names=storage=StorageMock storage
type storage interface {
	GetConfigParameter(ctx context.Context, key string) (string, error)
	GetTeams(ctx context.Context) ([]*models.Team, error)
	GetExploits(ctx context.Context) ([]*models.Exploit, error)
}

//go:generate mockgen -source=service.go -destination=./mocks/queue_mock.go -package=mocks -mock_names=queue=QueueMock queue
type queue interface {
	PublishFlag(flag *rabbitmq.Flag) error
}

type ExploitRunner struct {
	log              *slog.Logger
	queue            queue
	db               storage
	cfg              *config
	exploitSemaphore chan struct{}  // semaphore to limit concurrent exploits
	exploitWg        sync.WaitGroup // wait group to wait for all exploits to finish
	stopChan         chan struct{}  // channel to stop the exploit runner
}

func New(log *slog.Logger, db storage, queue queue, exploitDir string) (*ExploitRunner, error) {
	er := &ExploitRunner{
		log:      log,
		queue:    queue,
		db:       db,
		stopChan: make(chan struct{}),
		cfg: &config{
			exploitDirectory: exploitDir,
		},
		exploitWg: sync.WaitGroup{},
	}
	err := er.loadConfig(context.Background())
	if err != nil {
		return nil, fmt.Errorf("error loading exploit runner config: %w", err)
	}

	return er, nil
}

func (er *ExploitRunner) Start(ctx context.Context) {
	const op = "service.exploit_runner.Start"
	log := er.log.With(slog.String("op", op))

	log.Info("starting exploit runner")

	ticker := time.NewTicker(er.cfg.exploitRunDuration)
	for {
		select {
		case <-ticker.C:
			// every tick load new config from db
			err := er.loadConfig(context.Background())
			if err != nil {
				log.Error(
					"error reloading exploit runner config from db",
					prettylogger.Err(err),
				)
				continue
			}

			// get exploits from db
			exploits, err := er.db.GetExploits(ctx)
			if err != nil {
				log.Error(
					"error getting exploits from db",
					prettylogger.Err(err),
				)
				continue
			}

			if len(exploits) == 0 {
				log.Info("no exploits to run")
				continue
			}

			log.Info("starting exploits", slog.Int("teams_count", len(er.cfg.teams)))
			er.startExploits(exploits)
			ticker.Reset(er.cfg.exploitRunDuration)
		case <-er.stopChan:
			ticker.Stop()
			log.Info("exploit runner stopped")
			return
		}
	}
}

func (er *ExploitRunner) Stop() {
	const op = "service.exploit_runner.Stop"
	log := er.log.With(slog.String("op", op))

	log.Debug("stopping exploit runner")
	close(er.stopChan)
}
