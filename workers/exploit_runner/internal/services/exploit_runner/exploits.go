package exploit_runner

import (
	"bytes"
	"context"
	"exploit_runner/internal/models"
	"exploit_runner/pkg/rabbitmq_dto"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path"
	"time"

	"github.com/gabriel-vasile/mimetype"
	"github.com/jacute/prettylogger"
)

func (er *ExploitRunner) startExploits(exploits []*models.Exploit) {
	const op = "service.exploit_runner.StartExploits"
	log := er.log.With(slog.String("op", op))

	for _, exploit := range exploits {
		log = log.With(slog.String("exploit_path", exploit.ExecutablePath))
		file, err := os.Stat(exploit.ExecutablePath)
		if err != nil {
			log.Error(
				"error getting exploit file info",
				prettylogger.Err(err),
			)
			continue
		}

		exploitName := file.Name()
		err = os.Chmod(exploit.ExecutablePath, 0744)
		if err != nil {
			log.Error(
				"error chmoding exploit",
				prettylogger.Err(err),
			)
			continue
		}

		buf, err := os.ReadFile(exploit.ExecutablePath)
		if err != nil {
			log.Error(
				"error reading exploit",
				prettylogger.Err(err),
			)
			continue
		}
		kind := mimetype.Detect(buf)

		switch {
		case kind.Is("text/plain"): // for exploits written on interpreted languages
			extension := path.Ext(exploitName)
			switch extension {
			case ".py":
				er.exploitWg.Add(1)

				go func() {
					defer er.exploitWg.Done()

					ctx, cancel := context.WithTimeout(context.Background(), er.cfg.venvMaxInstallTime)
					exploitDir := path.Dir(exploit.ExecutablePath)
					interpreter := "python3"

					if exploit.RequirementsPath != nil && *exploit.RequirementsPath != "" {
						venvDir := path.Join(exploitDir, "venv")
						if _, err := os.Stat(venvDir); os.IsNotExist(err) {
							err = installPythonVenv(ctx, venvDir, *exploit.RequirementsPath)
							cancel()
							if err != nil {
								log.Error(
									"error installing python venv",
									prettylogger.Err(err),
								)
								return
							}
							log.Info("venv for exploit installed successfully", slog.String("venv_path", venvDir))
						}
						interpreter = path.Join(venvDir, "bin", "python")
					}

					er.startExploit(exploit, interpreter)
				}()
			case ".sh":
				fmt.Println("TODO: implement bash exploit runner")
			default:
				log.Error(
					"unsupported exploit extension",
					slog.String("extension", extension),
				)
				continue
			}
		case kind.Is("application/x-executable"): // for exploits written on compiled languages
			er.exploitWg.Add(1)

			go func() {
				defer er.exploitWg.Done()
				er.startExploit(exploit, "")
			}()
		default:
			log.Warn(
				"unknown filetype exploit",
				slog.String("mime_type", kind.String()),
			)
		}
	}
	er.exploitWg.Wait()
}

func (er *ExploitRunner) startExploit(exploit *models.Exploit, interpreter string) {
	const op = "service.exploit_runner.startExploit"
	log := er.log.With(slog.String("op", op), slog.String("exploit_path", exploit.ExecutablePath), slog.String("exploit_name", exploit.Name))

	log.Info("starting exploit on teams", slog.Int("teams_count", len(er.cfg.teams)))

	for _, team := range er.cfg.teams {
		log = log.With(slog.String("team_ip", team.IP.String()))
		ctx, cancel := context.WithTimeout(context.Background(), er.cfg.exploitMaxWorkingTime)

		er.exploitSemaphore <- struct{}{}
		go func(team *models.Team, log *slog.Logger) {
			defer func() {
				cancel()
				<-er.exploitSemaphore
			}()

			cmd, err := execExploit(ctx, exploit, interpreter, team.IP.String())
			if err != nil {
				log.Error(
					"error creating exploit command",
					prettylogger.Err(err),
				)
				return
			}
			var stdoutBuf, stderrBuf bytes.Buffer
			cmd.Stdout = &stdoutBuf
			cmd.Stderr = &stderrBuf

			if err := cmd.Start(); err != nil {
				log.Error(
					"error starting exploit",
					prettylogger.Err(err),
				)
				return
			}

			if err := cmd.Wait(); err != nil {
				log.Error(
					"error waiting for exploit to finish",
					slog.String("stdout", stdoutBuf.String()),
					slog.String("stderr", stderrBuf.String()),
					prettylogger.Err(err),
				)
				return
			}

			teamFlags := er.cfg.flagFormatRegexp.FindAllString(stdoutBuf.String(), -1)
			for _, flag := range teamFlags {
				err := er.queue.PublishFlag(&rabbitmq_dto.Flag{
					Value:      flag,
					TeamID:     team.ID,
					ExploitID:  exploit.ID,
					SourceType: rabbitmq_dto.FarmExploitSourceType,
					CreatedAt:  time.Now().UTC(),
				})
				if err != nil {
					log.Error(
						"error publishing flag to queue",
						prettylogger.Err(err),
					)
					continue
				}
				log.Info("published flag to queue", slog.String("flag", flag))
			}

			log.Info("exploit completed successfully", slog.String("team_ip", team.IP.String()))
		}(team, log)
	}
}

func execExploit(ctx context.Context, exploit *models.Exploit, interpreter, ip string) (*exec.Cmd, error) {
	var cmd *exec.Cmd
	if exploit.Type == "binary" {
		cmd = exec.CommandContext(ctx, exploit.ExecutablePath, ip)
	} else if exploit.Type == "python" || exploit.Type == "python_zip" {
		cmd = exec.CommandContext(ctx, interpreter, exploit.ExecutablePath, ip)
	} else {
		return nil, fmt.Errorf("unknown exploit type: %s", exploit.Type)
	}
	return cmd, nil
}

func installPythonVenv(ctx context.Context, venvDir, requirementsPath string) error {
	// Создаём venv
	cmd := exec.CommandContext(ctx, "python3", "-m", "venv", venvDir)
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("error installing python venv: %w\nOutput:\n%s", err, string(out))
	}

	// Устанавливаем зависимости
	pipPath := path.Join(venvDir, "bin", "pip3")
	cmd = exec.CommandContext(ctx, pipPath, "install", "-r", requirementsPath)
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("error installing python requirements: %w\nOutput:\n%s", err, string(out))
	}

	return nil
}
