package exploit_runner

import (
	"context"
	"exploit_runner/internal/models"
	"log/slog"
	"regexp"
	"strconv"
	"time"

	"github.com/jacute/prettylogger"
)

const (
	ConfigFlagFormatKey           = "EXPLOIT_RUNNER_FLAG_FORMAT"
	ConfigExploitDuration         = "EXPLOIT_RUNNER_DURATION"
	ConfigExploitMaxWorkingTime   = "EXPLOIT_RUNNER_MAX_WORKING_TIME"
	ConfigMaxConcurrentExploits   = "EXPLOIT_RUNNER_MAX_CONCURRENT_EXPLOITS"
	ConfigFlagSenderPlugin        = "FLAG_SENDER_PLUGIN"
	ConfigFlagSenderSubmitTimeout = "FLAG_SENDER_SUBMIT_TIMEOUT"
	ConfigFlagSenderSubmitPeriod  = "FLAG_SENDER_SUBMIT_PERIOD"
	ConfigFlagSenderJuryFlagURL   = "FLAG_SENDER_JURY_FLAG_URL_OR_HOST"
	ConfigFlagSenderToken         = "FLAG_SENDER_TOKEN"
	ConfigFlagSenderSubmitLimit   = "FLAG_SENDER_SUBMIT_LIMIT"
	ConfigFlagSenderFlagTTL       = "FLAG_SENDER_FLAG_TTL"
)

type config struct {
	teams                 []*models.Team
	flagFormatRegexp      *regexp.Regexp
	exploitRunDuration    time.Duration
	exploitMaxWorkingTime time.Duration
	maxConcurrentExploits int
	exploitDirectory      string
}

func (er *ExploitRunner) loadConfig(ctx context.Context) error {
	const op = "service.exploit_runner.loadConfig"
	log := er.log.With(slog.String("op", op))

	flagFormat, err := er.db.GetConfigParameter(ctx, ConfigFlagFormatKey)
	if err != nil {
		log.Error(
			"error getting flag format from db config",
			slog.String("config_key", ConfigFlagFormatKey),
			prettylogger.Err(err),
		)
		return err
	}
	flagFormatRegexp, err := regexp.Compile(flagFormat)
	if err != nil {
		log.Error(
			"error compiling flag format regexp",
			slog.String("flag_format", flagFormat),
			prettylogger.Err(err),
		)
		return err
	}

	teams, err := er.db.GetTeams(ctx)
	if err != nil {
		log.Error(
			"error getting teams from db config",
			prettylogger.Err(err),
		)
		return err
	}

	exploitDurationStr, err := er.db.GetConfigParameter(ctx, ConfigExploitDuration)
	if err != nil {
		log.Error(
			"error getting exploit run duration from db config",
			slog.String("config_key", ConfigExploitDuration),
			prettylogger.Err(err),
		)
		return err
	}
	exploitDuration, err := time.ParseDuration(exploitDurationStr)
	if err != nil {
		log.Error(
			"error parsing exploit duration",
			slog.String("value_to_parse", exploitDurationStr),
			prettylogger.Err(err),
		)
		return err
	}

	maxConcurrentExploitsStr, err := er.db.GetConfigParameter(ctx, ConfigMaxConcurrentExploits)
	if err != nil {
		log.Error(
			"error getting max concurrent exploits from db config",
			slog.String("config_key", ConfigMaxConcurrentExploits),
			prettylogger.Err(err),
		)
		return err
	}
	maxConcurrentExploits, err := strconv.Atoi(maxConcurrentExploitsStr)
	if err != nil {
		log.Error(
			"error parsing max concurrent exploits",
			slog.String("value_to_parse", maxConcurrentExploitsStr),
			prettylogger.Err(err),
		)
		return err
	}

	exploitMaxWorkingTimeStr, err := er.db.GetConfigParameter(ctx, ConfigExploitMaxWorkingTime)
	if err != nil {
		log.Error(
			"error getting exploit max working time from db config",
			slog.String("config_key", ConfigExploitMaxWorkingTime),
			prettylogger.Err(err),
		)
		return err
	}
	exploitMaxWorkingTime, err := time.ParseDuration(exploitMaxWorkingTimeStr)
	if err != nil {
		log.Error(
			"error parsing exploit max working time",
			slog.String("value_to_parse", exploitMaxWorkingTimeStr),
			prettylogger.Err(err),
		)
		return err
	}

	er.cfg.exploitRunDuration = exploitDuration
	er.cfg.teams = teams
	er.cfg.flagFormatRegexp = flagFormatRegexp
	er.cfg.maxConcurrentExploits = maxConcurrentExploits
	er.cfg.exploitMaxWorkingTime = exploitMaxWorkingTime
	er.exploitSemaphore = make(chan struct{}, maxConcurrentExploits)

	return nil
}
