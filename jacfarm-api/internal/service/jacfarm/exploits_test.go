package jacfarm

import (
	"JacFARM/internal/http/dto"
	"JacFARM/internal/models"
	"JacFARM/internal/service/jacfarm/mocks"
	"context"
	"fmt"
	"log/slog"
	"os"
	"path"
	"testing"

	"github.com/jacute/prettylogger"
	"github.com/stretchr/testify/require"
	"go.uber.org/mock/gomock"
)

type TestSuite struct {
	srv         *Service
	ctrl        *gomock.Controller
	exploitDir  string
	storageMock *mocks.StorageMock
	queueMock   *mocks.QueueMock
}

func newTestSuite(t *testing.T) *TestSuite {
	ctrl := gomock.NewController(t)
	storageMock := mocks.NewStorageMock(ctrl)
	queueMock := mocks.NewQueueMock(ctrl)

	exploitDir, err := os.MkdirTemp("/tmp", "jacfarm_test_exploits_")
	if err != nil {
		t.Fatal("cannot create temp dir in /tmp")
	}
	srv := New(slog.New(prettylogger.NewDiscardHandler()), storageMock, queueMock, exploitDir)

	return &TestSuite{
		srv:         srv,
		ctrl:        ctrl,
		exploitDir:  exploitDir,
		storageMock: storageMock,
		queueMock:   queueMock,
	}
}

func (ts *TestSuite) clean() error {
	return os.RemoveAll(ts.exploitDir)
}

func TestUploadExploit(t *testing.T) {
	suite := newTestSuite(t)
	defer suite.ctrl.Finish()

	t.Cleanup(func() {
		fmt.Println("ðŸ§¹ Cleaning up:", suite.exploitDir)
		suite.clean()
	})

	testcases := []struct {
		name        string
		exploit     *dto.UploadExploitRequest
		ctx         context.Context
		storageMock func() *mocks.StorageMock
		expectedErr error
	}{
		{
			name: "error type",
			exploit: &dto.UploadExploitRequest{
				Name: "aboba1",
				Type: "aboba2",
			},
			ctx: context.Background(),
			storageMock: func() *mocks.StorageMock {
				return suite.storageMock
			},
			expectedErr: ErrInvalidExploitType,
		},
		{
			name: "ok python",
			exploit: &dto.UploadExploitRequest{
				File:             []byte("print('Hello world')"),
				RequirementsFile: []byte("requests"),
				Type:             models.ExploitTypePython,
				Name:             "exploit1",
			},
			ctx: context.Background(),
			storageMock: func() *mocks.StorageMock {
				suite.storageMock.EXPECT().CreateExploit(gomock.Any(), gomock.Any()).Return(nil)
				return suite.storageMock
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(tt *testing.T) {
			storageMock := tc.storageMock()
			suite.srv.db = storageMock

			id, err := suite.srv.UploadExploit(tc.ctx, tc.exploit)
			require.ErrorIs(t, err, tc.expectedErr)
			if err != nil {
				return
			}

			require.NotEmpty(t, id)
			require.FileExists(t, path.Join(suite.exploitDir, id, "exploit.py"))
			require.FileExists(t, path.Join(suite.exploitDir, id, "requirements.txt"))
		})
	}
}

func TestDeleteExploit(t *testing.T) {
	suite := newTestSuite(t)
	defer suite.ctrl.Finish()

	t.Cleanup(func() {
		fmt.Println("ðŸ§¹ Cleaning up:", suite.exploitDir)
		suite.clean()
	})

	testcases := []struct {
		name        string
		id          string
		ctx         context.Context
		storageMock func() *mocks.StorageMock
		expectedErr error
	}{
		{
			name: "exploit dir not found",
			id:   "1",
			ctx:  context.Background(),
			storageMock: func() *mocks.StorageMock {
				return suite.storageMock
			},
			expectedErr: ErrExploitDirNotFound,
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(tt *testing.T) {
			storageMock := tc.storageMock()
			suite.srv.db = storageMock

			err := suite.srv.DeleteExploit(tc.ctx, tc.id)
			require.ErrorIs(t, err, tc.expectedErr)
			if err == nil {
				require.NoDirExists(t, path.Join(suite.exploitDir, tc.id))
			}
		})
	}
}
