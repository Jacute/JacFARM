package jacfarm

import (
	"JacFARM/internal/http/dto"
	"JacFARM/internal/models"
	storage_errors "JacFARM/internal/storage"
	"JacFARM/internal/utils"
	"context"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"path"

	"github.com/google/uuid"
	"github.com/jacute/prettylogger"
)

var (
	ErrExploitDirNotFound = errors.New("exploit dir not found")
	ErrInvalidExploitType = errors.New("invalid exploit type")
)

func (s *Service) ListExploits(ctx context.Context, filter *dto.ListExploitsFilter) ([]*models.Exploit, int, error) {
	const op = "service.jacfarm.ListExploits"
	log := s.log.With(slog.String("op", op))

	exploits, count, err := s.db.GetExploits(ctx, filter)
	if err != nil {
		log.Error("error listing exploits", prettylogger.Err(err))
		return nil, 0, err
	}
	log.Debug("successfully list exploits")

	return exploits, count, nil
}

func (s *Service) ListShortExploits(ctx context.Context) ([]*models.ExploitShort, error) {
	const op = "service.jacfarm.ListShortExploits"
	log := s.log.With(slog.String("op", op))

	exploits, err := s.db.GetShortExploits(ctx)
	if err != nil {
		log.Error("error listing short exploits", prettylogger.Err(err))
		return nil, err
	}
	log.Debug("successfully list short exploits")

	return exploits, nil
}

func (s *Service) ToggleExploit(ctx context.Context, id string) (bool, error) {
	const op = "service.jacfarm.ToggleExploit"
	log := s.log.With(slog.String("op", op))

	isRunning, err := s.db.ToggleExploit(ctx, id)
	if err != nil {
		log.Error("error toggling exploit", prettylogger.Err(err))
		return false, err
	}
	log.Debug("exploit successfully toggled", slog.Bool("is_running", isRunning))

	return isRunning, nil
}

func (s *Service) UploadExploit(ctx context.Context, req *dto.UploadExploitRequest) (string, error) {
	const op = "service.jacfarm.UploadExploit"
	exploitID := uuid.NewString()
	log := s.log.With(slog.String("op", op), slog.String("exploit_id", exploitID))

	exploitWorkDirPath := path.Join(s.exploitDir, exploitID)
	err := os.MkdirAll(exploitWorkDirPath, 0700)
	if err != nil {
		log.Error("error creating dir for exploit", slog.String("exploit_work_dir", exploitWorkDirPath), prettylogger.Err(err))
		return "", err
	}

	var exploitExecutablePath, requirementsPath string
	switch req.Type {
	case models.ExploitTypeBinary:
		exploitExecutablePath, requirementsPath, err = writeExploit(ctx, exploitWorkDirPath, "", "exploit", req)
		if err != nil {
			log.Error("error writing exploit", slog.String("exploit_type", string(req.Type)))
			return "", err
		}
	case models.ExploitTypeBash:
		exploitExecutablePath, requirementsPath, err = writeExploit(ctx, exploitWorkDirPath, "", "exploit.sh", req)
		if err != nil {
			log.Error("error writing exploit", slog.String("exploit_type", string(req.Type)))
			return "", err
		}
	case models.ExploitTypePython:
		exploitExecutablePath, requirementsPath, err = writeExploit(ctx, exploitWorkDirPath, "requirements.txt", "exploit.py", req)
		if err != nil {
			log.Error("error writing exploit", slog.String("exploit_type", string(req.Type)))
			return "", err
		}
	case models.ExploitTypePythonZip:
		err = utils.SecureUnzip(req.File, exploitWorkDirPath, 200*1024*1024, 50*1024*1024)
		if err != nil {
			return "", fmt.Errorf("%s: error unzipping %w", op, err)
		}
		exploitExecutablePath = path.Join(exploitWorkDirPath, "main.py")
		requirementsPath = path.Join(exploitWorkDirPath, "requirements.txt")
		if _, err = os.Stat(exploitExecutablePath); os.IsNotExist(err) {
			os.RemoveAll(exploitWorkDirPath)
			return "", fmt.Errorf("%s: main.py not found after unzipping", op)
		}
		if _, err = os.Stat(requirementsPath); os.IsNotExist(err) {
			os.RemoveAll(exploitWorkDirPath)
			return "", fmt.Errorf("%s: requirements.txt not found after unzipping", op)
		}
	default:
		log.Warn("invalid exploit type", slog.String("exploit_type", string(req.Type)))
		return "", fmt.Errorf("%s: %w", op, ErrInvalidExploitType)
	}

	err = s.db.CreateExploit(ctx, &models.Exploit{
		ID:               exploitID,
		Name:             req.Name,
		Type:             req.Type,
		IsRunningOnFarm:  true,
		ExecutablePath:   exploitExecutablePath,
		RequirementsPath: &requirementsPath,
		IsRunning:        true,
	})
	if err != nil {
		log.Error("error inserting exploit into db", prettylogger.Err(err))
		return "", err
	}

	log.Debug("exploit successfully uploaded", slog.String("exploit_id", exploitID))

	return exploitID, nil
}

func (s *Service) DeleteExploit(ctx context.Context, id string) error {
	const op = "service.jacfarm.DeleteExploit"
	log := s.log.With(slog.String("op", op), slog.String("id", id))

	exploitDirPath := path.Join(s.exploitDir, id)
	if _, err := os.Stat(exploitDirPath); os.IsNotExist(err) {
		log.Warn("exploit dir not found", slog.String("exploit_dir", exploitDirPath))
		return ErrExploitDirNotFound
	}

	// remove exploit dir
	err := os.RemoveAll(exploitDirPath)
	if err != nil {
		log.Error("error removing exploit dir", slog.String("exploit_dir", exploitDirPath), prettylogger.Err(err))
		return err
	}

	// delete db row
	err = s.db.DeleteExploit(ctx, id)
	if err != nil {
		if errors.Is(err, storage_errors.ErrExploitNotFound) {
			log.Warn("exploit row in db not found")
			return err
		}
		log.Error("error deleting exploit from db", prettylogger.Err(err))
		return err
	}

	log.Debug("successfully delete exploit")

	return nil
}

func writeExploit(ctx context.Context, exploitWorkDirPath, requirementsName, exploitName string, req *dto.UploadExploitRequest) (string, string, error) {
	const op = "service.jacfarm.writeExploit"

	exploitExecutablePath := path.Join(exploitWorkDirPath, exploitName)
	err := os.WriteFile(exploitExecutablePath, req.File, 0700)
	if err != nil {
		return "", "", fmt.Errorf("%s: %w", op, err)
	}

	var requirementsPath string
	if requirementsName != "" {
		requirementsPath = path.Join(exploitWorkDirPath, requirementsName)
		err = os.WriteFile(requirementsPath, req.RequirementsFile, 0700)
		if err != nil {
			return "", "", fmt.Errorf("%s: %w", op, err)
		}
	}

	return exploitExecutablePath, requirementsPath, nil
}
