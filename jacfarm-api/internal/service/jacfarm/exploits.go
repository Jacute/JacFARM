package jacfarm

import (
	"JacFARM/internal/http/dto"
	"JacFARM/internal/models"
	storage_errors "JacFARM/internal/storage"
	"context"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"path"

	"github.com/google/uuid"
	"github.com/jacute/prettylogger"
)

var (
	ErrExploitDirNotFound = errors.New("exploit dir not found")
)

func (s *Service) ListExploits(ctx context.Context, filter *dto.ListExploitsFilter) ([]*models.Exploit, int, error) {
	const op = "service.jacfarm.ListExploits"
	log := s.log.With(slog.String("op", op))

	exploits, count, err := s.db.GetExploits(ctx, filter)
	if err != nil {
		log.Error("error listing exploits", prettylogger.Err(err))
		return nil, 0, err
	}
	log.Info("successfully list exploits")

	return exploits, count, nil
}

func (s *Service) ListShortExploits(ctx context.Context) ([]*models.ExploitShort, error) {
	const op = "service.jacfarm.ListShortExploits"
	log := s.log.With(slog.String("op", op))

	exploits, err := s.db.GetShortExploits(ctx)
	if err != nil {
		log.Error("error listing short exploits", prettylogger.Err(err))
		return nil, err
	}
	log.Info("successfully list short exploits")

	return exploits, nil
}

func (s *Service) ToggleExploit(ctx context.Context, id string) (bool, error) {
	const op = "service.jacfarm.ToggleExploit"
	log := s.log.With(slog.String("op", op))

	isRunning, err := s.db.ToggleExploit(ctx, id)
	if err != nil {
		log.Error("error toggling exploit", prettylogger.Err(err))
		return false, err
	}
	log.Info("exploit successfully toggled", slog.Bool("is_running", isRunning))

	return isRunning, nil
}

func (s *Service) UploadExploit(ctx context.Context, req *dto.UploadExploitRequest) (string, error) {
	const op = "service.jacfarm.UploadExploit"
	exploitID := uuid.NewString()
	log := s.log.With(slog.String("op", op), slog.String("exploit_id", exploitID))

	exploitWorkDirPath := path.Join(s.exploitDir, exploitID)
	err := os.MkdirAll(exploitWorkDirPath, 0700)

	if err != nil {
		log.Error("error creating dir for exploit", slog.String("exploit_work_dir", exploitWorkDirPath), prettylogger.Err(err))
		return "", err
	}

	var exploitName string
	var requirementsName string
	switch req.Type {
	case models.ExploitTypeBinary:
		exploitName = "exploit"
	case models.ExploitTypeBash:
		exploitName = "exploit.sh"
	case models.ExploitTypePython:
		exploitName = "exploit.py"
		requirementsName = "requirements.txt"
	default:
		log.Warn("invalid exploit type", slog.String("exploit_type", string(req.Type)))
		return "", fmt.Errorf("%s: invalid exploit type", op)
	}

	exploitExecutablePath := path.Join(exploitWorkDirPath, exploitName)
	err = os.WriteFile(exploitExecutablePath, req.File, 0700)
	if err != nil {
		log.Error("error writing exploit", slog.String("exploit_path", exploitExecutablePath), prettylogger.Err(err))
		return "", err
	}

	var requirementsPath string
	if requirementsName != "" {
		requirementsPath = path.Join(exploitWorkDirPath, requirementsName)
		err = os.WriteFile(requirementsPath, req.RequirementsFile, 0700)
		if err != nil {
			log.Error("error writing exploit requirements", slog.String("requirements_path", requirementsPath), prettylogger.Err(err))
			return "", err
		}
	}

	err = s.db.CreateExploit(ctx, &models.Exploit{
		ID:               exploitID,
		Name:             req.Name,
		Type:             req.Type,
		IsRunningOnFarm:  true,
		ExecutablePath:   exploitExecutablePath,
		RequirementsPath: &requirementsPath,
		IsRunning:        true,
	})
	if err != nil {
		log.Error("error inserting exploit into db", prettylogger.Err(err))
		return "", err
	}

	log.Info("exploit successfully uploaded", slog.String("exploit_id", exploitID))

	return exploitID, nil
}

func (s *Service) DeleteExploit(ctx context.Context, id string) error {
	const op = "service.jacfarm.DeleteExploit"
	log := s.log.With(slog.String("op", op), slog.String("id", id))

	exploitDirPath := path.Join(s.exploitDir, id)
	if _, err := os.Stat(exploitDirPath); os.IsNotExist(err) {
		log.Warn("exploit dir not found", slog.String("exploit_dir", exploitDirPath))
		return ErrExploitDirNotFound
	}

	// remove exploit dir
	err := os.RemoveAll(exploitDirPath)
	if err != nil {
		log.Error("error removing exploit dir", slog.String("exploit_dir", exploitDirPath), prettylogger.Err(err))
		return err
	}

	// delete db row
	err = s.db.DeleteExploit(ctx, id)
	if err != nil {
		if errors.Is(err, storage_errors.ErrExploitNotFound) {
			log.Warn("exploit row in db not found")
			return err
		}
		log.Error("error deleting exploit from db", prettylogger.Err(err))
		return err
	}

	log.Info("successfully delete exploit")

	return nil
}
