package handlers

import (
	"JacFARM/internal/http/dto"
	"JacFARM/internal/models"
	"JacFARM/internal/service/jacfarm"
	"JacFARM/internal/storage"
	"errors"
	"io"
	"mime/multipart"

	"github.com/gofiber/fiber/v3"
	"github.com/google/uuid"
)

// ListExploits godoc
// @Summary Возврат полной информации об эксплойтах
// @Param limit query int false "Количество эксплойтов"
// @Param page query int false "Страница эксплойтов"
// @Produce json
// @Success 200 {object} dto.ListExploitsResponse
// @Failure 400 {object} dto.Response "Неверный запрос"
// @Failure 401 {object} dto.Response "Ошибка авторизации"
// @Failure 500 {object} dto.Response "Внутренняя ошибка"
// @Router /api/v1/exploits [get]
// @Tags Exploits
// @Security BasicAuth
func (h *Handlers) ListExploits() func(c fiber.Ctx) error {
	return func(c fiber.Ctx) error {
		filter, err := dto.MapQueryToGetExploitsFilter(c.Queries())
		if err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(dto.Error(err.Error()))
		}

		exploits, count, err := h.service.ListExploits(c.RequestCtx(), filter)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(dto.ErrInternal)
		}

		return c.JSON(dto.ListExploitsResponse{
			Response: dto.OK(),
			Exploits: exploits,
			Count:    count,
		})
	}
}

// ListShortExploits godoc
// @Summary Возврат короткой информации об эксплойтах
// @Produce json
// @Success 200 {object} dto.ListShortExploitsResponse
// @Failure 400 {object} dto.Response "Неверный запрос"
// @Failure 401 {object} dto.Response "Ошибка авторизации"
// @Failure 500 {object} dto.Response "Внутренняя ошибка"
// @Router /api/v1/exploits/short [get]
// @Tags Exploits
// @Security BasicAuth
func (h *Handlers) ListShortExploits() func(c fiber.Ctx) error {
	return func(c fiber.Ctx) error {
		exploits, err := h.service.ListShortExploits(c.RequestCtx())
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(dto.ErrInternal)
		}

		return c.JSON(dto.ListShortExploitsResponse{
			Response: dto.OK(),
			Exploits: exploits,
		})
	}
}

// UploadExploit godoc
// @Summary Загрузка эксплойта
// @Accept multipart/form-data
// @Produce json
// @Param name formData string true "Имя эксплойта"
// @Param type formData string true "Тип эксплойта (e.g. python)"
// @Param exploit formData file true "Файл эксплойта"
// @Param requirements formData file false "Файл requirements (только для python)"
// @Success 200 {object} dto.UploadExploitResponse
// @Failure 400 {object} dto.Response "Неверный запрос"
// @Failure 401 {object} dto.Response "Ошибка авторизации"
// @Failure 500 {object} dto.Response "Внутренняя ошибка"
// @Router /api/v1/exploits [post]
// @Tags Exploits
// @Security BasicAuth
func (h *Handlers) UploadExploit() func(c fiber.Ctx) error {
	return func(c fiber.Ctx) error {
		exploitHeader, err := c.FormFile("exploit")
		if err != nil || exploitHeader == nil {
			return c.Status(fiber.StatusBadRequest).JSON(dto.Error("error getting exploit"))
		}

		name := c.FormValue("name")
		typ := c.FormValue("type")

		var requirementsFileHeader *multipart.FileHeader
		if typ == string(models.ExploitTypePython) {
			requirementsFileHeader, err = c.FormFile("requirements")
			if err != nil {
				return c.Status(fiber.StatusBadRequest).JSON(dto.Error("error getting requirements"))
			}
		}

		var requirementsFileBytes []byte
		if requirementsFileHeader != nil {
			file, err := requirementsFileHeader.Open()
			if err != nil {
				return c.Status(fiber.StatusBadRequest).JSON(dto.Error("error opening requirements file"))
			}
			defer file.Close()
			requirementsFileBytes, err = io.ReadAll(file)
			if err != nil {
				return c.Status(fiber.StatusBadRequest).JSON(dto.Error("error reading requirements file"))
			}
		}

		file, err := exploitHeader.Open()
		if err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(dto.Error("error opening exploit"))
		}
		defer file.Close()
		exploitFileBytes, err := io.ReadAll(file)
		if err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(dto.Error("error reading exploit"))
		}

		req := &dto.UploadExploitRequest{
			Name:             name,
			Type:             models.ExploitType(typ),
			RequirementsFile: requirementsFileBytes,
			File:             exploitFileBytes,
		}

		if err := req.Validate(); err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(dto.Error(err.Error()))
		}

		id, err := h.service.UploadExploit(c.RequestCtx(), req)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(dto.ErrInternal)
		}

		return c.JSON(dto.UploadExploitResponse{
			Response: dto.OK(),
			ID:       id,
		})
	}
}

// ToggleExploit godoc
// @Summary Включение/выключение эксплойта
// @Produce json
// @Param id path string true "Exploit ID"
// @Success 200 {object} dto.ToggleExploitResponse
// @Failure 400 {object} dto.Response "Неверный запрос"
// @Failure 401 {object} dto.Response "Ошибка авторизации"
// @Failure 404 {object} dto.Response "Эксплойт не найден"
// @Failure 500 {object} dto.Response "Внутренняя ошибка"
// @Router /api/v1/exploits/{id}/toggle [post]
// @Tags Exploits
// @Security BasicAuth
func (h *Handlers) ToggleExploit() func(c fiber.Ctx) error {
	return func(c fiber.Ctx) error {
		id := c.Params("id")
		_, err := uuid.Parse(id)
		if err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(dto.Error("id should be uuid"))
		}

		isRunning, err := h.service.ToggleExploit(c.RequestCtx(), id)
		if err != nil {
			if errors.Is(err, storage.ErrExploitNotFound) {
				return c.Status(fiber.StatusNotFound).JSON(dto.Error(err.Error()))
			}
			return c.Status(fiber.StatusInternalServerError).JSON(dto.ErrInternal)
		}

		return c.JSON(dto.ToggleExploitResponse{
			Response:  dto.OK(),
			IsRunning: isRunning,
		})
	}
}

// DeleteExploit godoc
// @Summary Удаление эксплойта
// @Produce json
// @Param id path string true "Exploit ID"
// @Success 200 {object} dto.Response
// @Failure 400 {object} dto.Response "Неверный запрос"
// @Failure 401 {object} dto.Response "Ошибка авторизации"
// @Failure 500 {object} dto.Response "Внутренняя ошибка"
// @Router /api/v1/exploits/{id} [delete]
// @Tags Exploits
// @Security BasicAuth
func (h *Handlers) DeleteExploit() func(c fiber.Ctx) error {
	return func(c fiber.Ctx) error {
		id := c.Params("id")
		_, err := uuid.Parse(id)
		if err != nil {
			return c.JSON(dto.Error("id should be uuid"))
		}

		err = h.service.DeleteExploit(c.RequestCtx(), id)
		if err != nil {
			if errors.Is(err, storage.ErrExploitNotFound) || errors.Is(err, jacfarm.ErrExploitDirNotFound) {
				return c.JSON(dto.Error(err.Error()))
			}
			return c.JSON(dto.ErrInternal)
		}

		return c.JSON(dto.OK())
	}
}
