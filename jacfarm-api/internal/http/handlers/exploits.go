package handlers

import (
	"JacFARM/internal/http/dto"
	"JacFARM/internal/models"
	"JacFARM/internal/storage"
	"errors"
	"io"
	"mime/multipart"

	"github.com/gofiber/fiber/v3"
	"github.com/google/uuid"
)

func (h *Handlers) ListExploits() func(c fiber.Ctx) error {
	return func(c fiber.Ctx) error {
		filter, err := dto.MapQueryToGetExploitsFilter(c.Queries())
		if err != nil {
			return c.JSON(dto.Error(err.Error()))
		}

		exploits, err := h.service.ListExploits(c.RequestCtx(), filter)
		if err != nil {
			return c.JSON(dto.ErrInternal)
		}

		return c.JSON(dto.ListExploitsResponse{
			Response: dto.OK(),
			Exploits: exploits,
		})
	}
}

func (h *Handlers) UploadExploit() func(c fiber.Ctx) error {
	return func(c fiber.Ctx) error {
		exploitHeader, err := c.FormFile("exploit")
		if err != nil || exploitHeader == nil {
			return c.JSON(dto.Error("error getting exploit"))
		}

		name := c.FormValue("name")
		typ := c.FormValue("type")

		var requirementsFileHeader *multipart.FileHeader
		if typ == string(models.ExploitTypePython) {
			requirementsFileHeader, err = c.FormFile("requirements")
			if err != nil {
				return c.JSON(dto.Error("error getting requirements"))
			}
		}

		var requirementsFileBytes []byte
		if requirementsFileHeader != nil {
			file, err := requirementsFileHeader.Open()
			if err != nil {
				return c.JSON(dto.Error("error opening requirements file"))
			}
			requirementsFileBytes, err = io.ReadAll(file)
			if err != nil {
				return c.JSON(dto.Error("error reading requirements file"))
			}
			file.Close()
		}

		file, err := exploitHeader.Open()
		if err != nil {
			return c.JSON(dto.Error("error opening exploit"))
		}
		exploitFileBytes, err := io.ReadAll(file)
		if err != nil {
			return c.JSON(dto.Error("error reading exploit"))
		}
		file.Close()

		req := &dto.UploadExploitRequest{
			Name:             name,
			Type:             models.ExploitType(typ),
			RequirementsFile: requirementsFileBytes,
			File:             exploitFileBytes,
		}

		if err := req.Validate(); err != nil {
			return c.JSON(dto.Error(err.Error()))
		}

		id, err := h.service.UploadExploit(c.RequestCtx(), req)
		if err != nil {
			c.JSON(dto.ErrInternal)
		}

		return c.JSON(dto.UploadExploitResponse{
			Response: dto.OK(),
			ID:       id,
		})
	}
}

func (h *Handlers) ToggleExploit() func(c fiber.Ctx) error {
	return func(c fiber.Ctx) error {
		id := c.Params("id")
		_, err := uuid.Parse(id)
		if err != nil {
			return c.JSON(dto.Error("id should be uuid"))
		}

		isRunning, err := h.service.ToggleExploit(c.RequestCtx(), id)
		if err != nil {
			if errors.Is(err, storage.ErrExploitNotFound) {
				return c.JSON(dto.Error(err.Error()))
			}
			return c.JSON(dto.ErrInternal)
		}

		return c.JSON(dto.ToggleExploitResponse{
			Response:  dto.OK(),
			IsRunning: isRunning,
		})
	}
}
