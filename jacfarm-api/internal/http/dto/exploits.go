package dto

import (
	"JacFARM/internal/models"
	"encoding/base64"
	"fmt"
	"strconv"

	"github.com/gabriel-vasile/mimetype"
)

type ListExploitsFilter struct {
	Limit uint64
	Page  uint64
}

type ListExploitsResponse struct {
	*Response
	Exploits []*models.Exploit `json:"exploits"`
}

func MapQueryToGetExploitsFilter(queries map[string]string) (*ListExploitsFilter, error) {
	var limit int
	limitStr, ok := queries["limit"]
	if ok && limitStr != "" {
		var err error
		limit, err = strconv.Atoi(limitStr)
		if err != nil {
			return nil, fmt.Errorf("limit should be number")
		}
	}
	if limit < 0 {
		return nil, fmt.Errorf("limit should be positive number")
	}

	var page int
	pageStr, ok := queries["page"]
	if ok && pageStr != "" {
		var err error
		page, err = strconv.Atoi(pageStr)
		if err != nil {
			return nil, fmt.Errorf("page should be number")
		}
	}
	if page < 0 {
		return nil, fmt.Errorf("page should be positive number")
	}

	return &ListExploitsFilter{
		Limit: uint64(limit),
		Page:  uint64(page),
	}, nil
}

type ToggleExploitResponse struct {
	*Response
	IsRunning bool `json:"is_running"`
}

type ExploitType string

var (
	BinaryExploitType ExploitType = "binary"
	BashExploitType   ExploitType = "bash"
	PythonExploitType ExploitType = "python"
)

type UploadExploitRequest struct {
	File             string      `json:"file"`              // file in base64
	RequirementsFile string      `json:"requirements_file"` // only for type 'python'
	Name             string      `json:"name,omitempty"`
	Type             ExploitType `json:"type"` // exploit type: bash, python, binary
}

type UploadExploitDecodedRequest struct {
	File             []byte
	RequirementsFile []byte
	Name             string
	Type             ExploitType
}

type UploadExploitResponse struct {
	*Response
	ID string `json:"id"`
}

func (req *UploadExploitDecodedRequest) Validate() error {
	if len(req.Name) > 100 {
		return fmt.Errorf("name should be shorter than 100 characters")
	}

	if req.Type == PythonExploitType && req.File != nil {
		reqKind := mimetype.Detect(req.RequirementsFile)
		if !reqKind.Is("text/plain") {
			return fmt.Errorf("'requirements_file' has incorrect mime type")
		}
	}

	kind := mimetype.Detect(req.File)
	if kind.Is("application/x-executable") && req.Type == BinaryExploitType {
		return nil
	}
	if kind.Is("text/plain") && (req.Type == BashExploitType || req.Type == PythonExploitType) {
		return nil
	}

	return fmt.Errorf("'file' doesn't match 'type'")
}

func UploadExploitDecode(req *UploadExploitRequest) (*UploadExploitDecodedRequest, error) {
	decodedReq := UploadExploitDecodedRequest{}
	_, err := base64.RawStdEncoding.Decode([]byte(req.File), decodedReq.File)
	if err != nil {
		return nil, fmt.Errorf("error decoding 'file'")
	}

	if req.Type == PythonExploitType {
		_, err = base64.RawStdEncoding.Decode([]byte(req.RequirementsFile), decodedReq.RequirementsFile)
		if err != nil {
			return nil, fmt.Errorf("error decoding 'requirements_file'")
		}
	}

	decodedReq.Name = req.Name
	decodedReq.Type = req.Type

	return &decodedReq, nil
}
