package exploit_runner

import (
	"JacFARM/internal/models"
	"bufio"
	"context"
	"log/slog"
	"os"
	"os/exec"
	"path"

	"github.com/gabriel-vasile/mimetype"
	"github.com/jacute/prettylogger"
)

func (er *ExploitRunner) startExploits() {
	const op = "service.exploit_runner.StartExploits"
	log := er.log.With(slog.String("op", op))

	entries, err := os.ReadDir(er.cfg.exploitDirectory)
	if err != nil {
		log.Error("error reading exploit dir", prettylogger.Err(err))
		return
	}
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		exploitName := entry.Name()
		exploitPath := path.Join(er.cfg.exploitDirectory, exploitName)
		log = er.log.With(slog.String("exploit_path", exploitPath))

		err := os.Chmod(exploitPath, 0744)
		if err != nil {
			log.Error(
				"error chmoding exploit",
				prettylogger.Err(err),
			)
			continue
		}

		buf, err := os.ReadFile(exploitPath)
		if err != nil {
			log.Error(
				"error reading exploit",
				prettylogger.Err(err),
			)
			continue
		}
		kind := mimetype.Detect(buf)

		switch {
		case kind.Is("text/plain"): // for exploits written on interpreted languages
			if !hasShebang(buf) {
				log.Warn(
					"exploit does not have a shebang, skipping",
				)
				continue
			}

			extension := path.Ext(exploitName)
			switch extension {
			case ".py":
				go er.startExploit(exploitPath, exploitName)
			case ".sh":
				go er.startExploit(exploitPath, exploitName)
			default:
				log.Error(
					"unsupported exploit extension",
					slog.String("extension", extension),
				)
				continue
			}
		case kind.Is("application/x-executable"): // for exploits written on compiled languages
			go er.startExploit(exploitPath, exploitName)
		default:
			log.Warn(
				"unknown filetype exploit",
				slog.String("mime_type", kind.String()),
			)
		}
	}
}

func (er *ExploitRunner) startExploit(exploitPath, exploitName string) {
	const op = "service.exploit_runner.startExploit"
	log := er.log.With(slog.String("op", op), slog.String("exploit_path", exploitPath))

	log.Info("starting exploit on teams", slog.Int("teams_count", len(er.cfg.teams)))

	for _, team := range er.cfg.teams {
		log = log.With(slog.String("team_ip", team.IP))
		ctx, cancel := context.WithTimeout(context.Background(), er.cfg.exploitMaxWorkingTime)

		er.exploitSemaphore <- struct{}{}
		go func(team *models.Team) {
			defer func() {
				cancel()
				<-er.exploitSemaphore
			}()

			cmd := exec.CommandContext(ctx, exploitPath, team.IP)

			stdoutPipe, err := cmd.StdoutPipe()
			if err != nil {
				log.Error(
					"error getting stdout pipe for exploit",
					prettylogger.Err(err),
				)
				return
			}

			if err := cmd.Start(); err != nil {
				log.Error(
					"error starting exploit",
					prettylogger.Err(err),
				)
				return
			}

			scanner := bufio.NewScanner(stdoutPipe)
			if err := cmd.Wait(); err != nil {
				log.Error(
					"error waiting for exploit to finish",
					prettylogger.Err(err),
				)
				return
			}
			scanner.Scan()
			output := scanner.Text()
			teamFlags := er.cfg.flagFormatRegexp.FindAllString(output, -1)
			for _, flag := range teamFlags {
				er.queue.PublishFlag(&models.Flag{
					Value:       flag,
					GetFrom:     team,
					ExploitName: exploitName,
				})
			}
		}(team)
	}
}

func hasShebang(data []byte) bool {
	return len(data) > 2 && data[0] == '#' && data[1] == '!'
}
