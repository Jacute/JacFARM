package exploit_runner

import (
	"JacFARM/internal/models"
	"JacFARM/internal/rabbitmq"
	"bufio"
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path"

	"github.com/gabriel-vasile/mimetype"
	"github.com/jacute/prettylogger"
)

func (er *ExploitRunner) startExploits(exploits []*models.Exploit) {
	const op = "service.exploit_runner.StartExploits"
	log := er.log.With(slog.String("op", op))

	for _, exploit := range exploits {
		log = log.With(slog.String("exploit_path", exploit.ExecutablePath))
		file, err := os.Stat(exploit.ExecutablePath)
		if err != nil {
			log.Error(
				"error getting exploit file info",
				prettylogger.Err(err),
			)
			continue
		}

		exploitName := file.Name()
		err = os.Chmod(exploit.ExecutablePath, 0744)
		if err != nil {
			log.Error(
				"error chmoding exploit",
				prettylogger.Err(err),
			)
			continue
		}

		buf, err := os.ReadFile(exploit.ExecutablePath)
		if err != nil {
			log.Error(
				"error reading exploit",
				prettylogger.Err(err),
			)
			continue
		}
		kind := mimetype.Detect(buf)

		switch {
		case kind.Is("text/plain"): // for exploits written on interpreted languages
			if hasShebang(buf) {
				log.Warn(
					"interpreter exploit should be without shebang",
				)
				continue
			}

			extension := path.Ext(exploitName)
			switch extension {
			case ".py":
				fmt.Println("TODO: implement python exploit runner")
			case ".sh":
				fmt.Println("TODO: implement bash exploit runner")
			default:
				log.Error(
					"unsupported exploit extension",
					slog.String("extension", extension),
				)
				continue
			}
		case kind.Is("application/x-executable"): // for exploits written on compiled languages
			er.exploitWg.Add(1)
			go er.startBinaryExploit(exploit, exploitName)
		default:
			log.Warn(
				"unknown filetype exploit",
				slog.String("mime_type", kind.String()),
			)
		}
	}
	er.exploitWg.Wait()
}

func (er *ExploitRunner) startBinaryExploit(exploit *models.Exploit, exploitName string) {
	defer er.exploitWg.Done()

	const op = "service.exploit_runner.startExploit"
	log := er.log.With(slog.String("op", op), slog.String("exploit_path", exploit.ExecutablePath))

	log.Info("starting binary exploit on teams", slog.Int("teams_count", len(er.cfg.teams)))

	for _, team := range er.cfg.teams {
		log = log.With(slog.String("team_ip", team.IP))
		ctx, cancel := context.WithTimeout(context.Background(), er.cfg.exploitMaxWorkingTime)

		er.exploitSemaphore <- struct{}{}
		go func(team *models.Team) {
			defer func() {
				cancel()
				<-er.exploitSemaphore
			}()

			cmd := exec.CommandContext(ctx, exploit.ExecutablePath, team.IP)

			stdoutPipe, err := cmd.StdoutPipe()
			if err != nil {
				log.Error(
					"error getting stdout pipe for exploit",
					prettylogger.Err(err),
				)
				return
			}

			if err := cmd.Start(); err != nil {
				log.Error(
					"error starting exploit",
					prettylogger.Err(err),
				)
				return
			}

			scanner := bufio.NewScanner(stdoutPipe)
			for scanner.Scan() {
				line := scanner.Text()
				teamFlags := er.cfg.flagFormatRegexp.FindAllString(line, -1)
				for _, flag := range teamFlags {
					err := er.queue.PublishFlag(&rabbitmq.Flag{
						Value:       flag,
						GetFrom:     team,
						ExploitName: exploitName,
					})
					if err != nil {
						log.Error(
							"error publishing flag to queue",
							prettylogger.Err(err),
						)
						continue
					}
					log.Info("published flag to queue", slog.String("flag", flag))
				}
			}

			if err := cmd.Wait(); err != nil {
				log.Error(
					"error waiting for exploit to finish",
					prettylogger.Err(err),
				)
				return
			}
		}(team)
	}
}

func hasShebang(data []byte) bool {
	return len(data) > 2 && data[0] == '#' && data[1] == '!'
}
