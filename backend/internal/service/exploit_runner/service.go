package exploit_runner

import (
	"JacFARM/internal/models"
	"JacFARM/internal/rabbitmq"
	jacfarm "JacFARM/internal/service/JacFARM"
	"context"
	"log/slog"
	"regexp"
	"strconv"
	"sync"
	"time"

	"github.com/jacute/prettylogger"
)

type storage interface {
	GetConfigParameter(ctx context.Context, key string) (string, error)
	GetTeams(ctx context.Context) ([]*models.Team, error)
	GetExploits(ctx context.Context) ([]*models.Exploit, error)
}

type queue interface {
	PublishFlag(flag *rabbitmq.Flag) error
}

type config struct {
	teams                 []*models.Team
	flagFormatRegexp      *regexp.Regexp
	exploitRunDuration    time.Duration
	exploitMaxWorkingTime time.Duration
	maxConcurrentExploits int
	exploitDirectory      string
}

type ExploitRunner struct {
	log              *slog.Logger
	queue            queue
	db               storage
	cfg              *config
	exploitSemaphore chan struct{}  // semaphore to limit concurrent exploits
	exploitWg        sync.WaitGroup // wait group to wait for all exploits to finish
	stopChan         chan struct{}  // channel to stop the exploit runner
}

func New(log *slog.Logger, db storage, queue queue, exploitDir string) *ExploitRunner {
	er := &ExploitRunner{
		log:      log,
		queue:    queue,
		db:       db,
		stopChan: make(chan struct{}),
		cfg: &config{
			exploitDirectory: exploitDir,
		},
		exploitWg: sync.WaitGroup{},
	}
	err := er.LoadConfig(context.Background())
	if err != nil {
		panic("error loading exploit runner config: " + err.Error())
	}

	return er
}

func (er *ExploitRunner) LoadConfig(ctx context.Context) error {
	const op = "service.exploit_runner.LoadConfig"
	log := er.log.With(slog.String("op", op))

	flagFormat, err := er.db.GetConfigParameter(ctx, jacfarm.ConfigFlagFormatKey)
	if err != nil {
		log.Error(
			"error getting flag format from db config",
			slog.String("config_key", jacfarm.ConfigFlagFormatKey),
			prettylogger.Err(err),
		)
		return err
	}
	flagFormatRegexp, err := regexp.Compile(flagFormat)
	if err != nil {
		log.Error(
			"error compiling flag format regexp",
			slog.String("flag_format", flagFormat),
			prettylogger.Err(err),
		)
		return err
	}

	teams, err := er.db.GetTeams(ctx)
	if err != nil {
		log.Error(
			"error getting teams from db config",
			prettylogger.Err(err),
		)
		return err
	}

	exploitDurationStr, err := er.db.GetConfigParameter(ctx, jacfarm.ConfigExploitDuration)
	if err != nil {
		log.Error(
			"error getting exploit run duration from db config",
			slog.String("config_key", jacfarm.ConfigExploitDuration),
			prettylogger.Err(err),
		)
		return err
	}
	exploitDuration, err := time.ParseDuration(exploitDurationStr)
	if err != nil {
		log.Error(
			"error parsing exploit duration",
			slog.String("value_to_parse", exploitDurationStr),
			prettylogger.Err(err),
		)
		return err
	}

	maxConcurrentExploitsStr, err := er.db.GetConfigParameter(ctx, jacfarm.ConfigMaxConcurrentExploits)
	if err != nil {
		log.Error(
			"error getting max concurrent exploits from db config",
			slog.String("config_key", jacfarm.ConfigMaxConcurrentExploits),
			prettylogger.Err(err),
		)
	}
	maxConcurrentExploits, err := strconv.Atoi(maxConcurrentExploitsStr)
	if err != nil {
		log.Error(
			"error parsing max concurrent exploits",
			slog.String("value_to_parse", maxConcurrentExploitsStr),
			prettylogger.Err(err),
		)
	}

	exploitMaxWorkingTimeStr, err := er.db.GetConfigParameter(ctx, jacfarm.ConfigExploitMaxWorkingTime)
	if err != nil {
		log.Error(
			"error getting exploit max working time from db config",
			slog.String("config_key", jacfarm.ConfigExploitMaxWorkingTime),
			prettylogger.Err(err),
		)
	}
	exploitMaxWorkingTime, err := time.ParseDuration(exploitMaxWorkingTimeStr)
	if err != nil {
		log.Error(
			"error parsing exploit max working time",
			slog.String("value_to_parse", exploitMaxWorkingTimeStr),
			prettylogger.Err(err),
		)
	}

	er.cfg.exploitRunDuration = exploitDuration
	er.cfg.teams = teams
	er.cfg.flagFormatRegexp = flagFormatRegexp
	er.cfg.maxConcurrentExploits = maxConcurrentExploits
	er.cfg.exploitMaxWorkingTime = exploitMaxWorkingTime
	er.exploitSemaphore = make(chan struct{}, maxConcurrentExploits)

	return nil
}

func (er *ExploitRunner) Start(ctx context.Context) {
	const op = "service.exploit_runner.Start"
	log := er.log.With(slog.String("op", op))

	log.Info("starting exploit runner")
	err := er.LoadConfig(ctx)
	if err != nil {
		log.Error(
			"error loading exploit runner config from db",
			prettylogger.Err(err),
		)
		return
	}

	ticker := time.NewTicker(er.cfg.exploitRunDuration)
	for {
		select {
		case <-ticker.C:
			// every tick load new config from db
			err := er.LoadConfig(context.Background())
			if err != nil {
				log.Error(
					"error reloading exploit runner config from db",
					prettylogger.Err(err),
				)
				continue
			}

			// get exploits from db
			exploits, err := er.db.GetExploits(ctx)
			if err != nil {
				log.Error(
					"error getting exploits from db",
					prettylogger.Err(err),
				)
				continue
			}

			log.Info("starting exploits", slog.Int("teams_count", len(er.cfg.teams)))
			er.startExploits(exploits)
			ticker.Reset(er.cfg.exploitRunDuration)
		case <-er.stopChan:
			ticker.Stop()
			close(er.stopChan)
			return
		}
	}
}

func (er *ExploitRunner) Stop() {
	const op = "service.exploit_runner.Stop"
	log := er.log.With(slog.String("op", op))

	log.Info("stopping exploit runner")
	er.stopChan <- struct{}{}
}
