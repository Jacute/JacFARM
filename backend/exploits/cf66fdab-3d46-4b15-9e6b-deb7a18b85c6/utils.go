package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"time"
)

const JuryHost = "http://10.10.10.10"

type LoginResponse struct {
	Status string `json:"status"`
	Token  string `json:"token"`
}

func generateRandom(n int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	seed := rand.New(rand.NewSource(time.Now().UnixNano()))
	b := make([]byte, n)
	for i := range b {
		b[i] = charset[seed.Intn(len(charset))]
	}
	return string(b)
}

func register(url, username, password, role string) error {
	data := map[string]string{
		"username": username,
		"password": password,
		"role":     role,
	}
	body, _ := json.Marshal(data)

	resp, err := http.Post(url+"/register", "application/json", bytes.NewReader(body))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		b, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("register failed: %s", b)
	}
	return nil
}

func login(url, username, password string) (*http.Client, error) {
	data := map[string]string{
		"username": username,
		"password": password,
	}
	body, _ := json.Marshal(data)

	client := &http.Client{}
	req, _ := http.NewRequest("POST", url+"/login", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result LoginResponse
	b, _ := io.ReadAll(resp.Body)
	if err := json.Unmarshal(b, &result); err != nil {
		return nil, err
	}

	if result.Status == "BAD" {
		return nil, errors.New("login failed: " + string(b))
	}

	// Inject the token as a cookie
	client.Transport = &TransportWithCookie{
		Token: result.Token,
		Base:  http.DefaultTransport,
	}

	return client, nil
}

// custom transport to inject cookie
type TransportWithCookie struct {
	Token string
	Base  http.RoundTripper
}

func (t *TransportWithCookie) RoundTrip(req *http.Request) (*http.Response, error) {
	req.AddCookie(&http.Cookie{Name: "token", Value: t.Token})
	return t.Base.RoundTrip(req)
}

func AttackData(host string) ([]string, error) {
	resp, err := http.Get(JuryHost + "/api/client/attack_data")
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var fullData map[string]map[string][]string
	body, _ := io.ReadAll(resp.Body)
	if err := json.Unmarshal(body, &fullData); err != nil {
		return nil, err
	}

	duties, ok := fullData["DutyManager"][host]
	if !ok {
		return nil, fmt.Errorf("no data for host %s", host)
	}
	return duties, nil
}
